# frozen_string_literal: true

require 'spec_helper'

RSpec.describe 'Vulnerability workflow', :integration do
  let(:access_key) { 'test-access-key' }
  let(:secret_key) { 'test-secret-key' }
  let(:base_url) { 'https://cloud.tenable.com' }
  let(:vulnerabilities_url) { "#{base_url}/workbenches/vulnerabilities" }

  let(:client) { Tenable::Client.new(access_key: access_key, secret_key: secret_key) }

  let(:vulnerability_list_body) do
    {
      'vulnerabilities' => [
        {
          'count' => 5,
          'plugin_family' => 'General',
          'plugin_id' => 11111,
          'plugin_name' => 'SSL Certificate Expired',
          'severity' => 4,
          'vulnerability_state' => 'open'
        },
        {
          'count' => 2,
          'plugin_family' => 'Web Servers',
          'plugin_id' => 22222,
          'plugin_name' => 'HTTP TRACE Method Enabled',
          'severity' => 2,
          'vulnerability_state' => 'open'
        },
        {
          'count' => 1,
          'plugin_family' => 'Databases',
          'plugin_id' => 33333,
          'plugin_name' => 'PostgreSQL Unsupported Version',
          'severity' => 3,
          'vulnerability_state' => 'reopened'
        }
      ]
    }
  end

  describe 'list vulnerabilities and iterate results' do
    before do
      stub_request(:get, vulnerabilities_url)
        .with(headers: { 'X-ApiKeys' => "accessKey=#{access_key};secretKey=#{secret_key};" })
        .to_return(
          status: 200,
          headers: { 'Content-Type' => 'application/json' },
          body: vulnerability_list_body.to_json
        )
    end

    it 'creates a client and lists vulnerabilities' do
      response = client.vulnerabilities.list

      expect(response).to be_a(Hash)
      expect(response).to have_key('vulnerabilities')
      expect(response['vulnerabilities']).to be_an(Array)
      expect(response['vulnerabilities'].length).to eq(3)
    end

    it 'returns vulnerability objects as Hashes with expected data' do
      response = client.vulnerabilities.list
      vulns = response['vulnerabilities']

      vulns.each do |vuln|
        expect(vuln).to be_a(Hash)
        expect(vuln).to have_key('plugin_id')
        expect(vuln).to have_key('plugin_name')
        expect(vuln).to have_key('severity')
        expect(vuln).to have_key('vulnerability_state')
        expect(vuln['plugin_id']).to be_a(Integer)
        expect(vuln['severity']).to be_a(Integer)
      end
    end

    it 'allows iteration over all vulnerability records' do
      response = client.vulnerabilities.list
      plugin_ids = response['vulnerabilities'].map { |v| v['plugin_id'] }

      expect(plugin_ids).to contain_exactly(11111, 22222, 33333)
    end
  end

  describe 'filter vulnerabilities by severity' do
    let(:filtered_body) do
      {
        'vulnerabilities' => [
          {
            'count' => 5,
            'plugin_family' => 'General',
            'plugin_id' => 11111,
            'plugin_name' => 'SSL Certificate Expired',
            'severity' => 4,
            'vulnerability_state' => 'open'
          }
        ]
      }
    end

    before do
      stub_request(:get, vulnerabilities_url)
        .with(
          headers: { 'X-ApiKeys' => "accessKey=#{access_key};secretKey=#{secret_key};" },
          query: hash_including('severity' => '4')
        )
        .to_return(
          status: 200,
          headers: { 'Content-Type' => 'application/json' },
          body: filtered_body.to_json
        )
    end

    it 'passes the severity filter param to the API' do
      response = client.vulnerabilities.list('severity' => '4')

      expect(response).to be_a(Hash)
      expect(response['vulnerabilities'].length).to eq(1)
      expect(response['vulnerabilities'].first['severity']).to eq(4)
    end

    it 'verifies the filter request was made with the correct parameter' do
      client.vulnerabilities.list('severity' => '4')

      expect(
        a_request(:get, vulnerabilities_url)
          .with(query: hash_including('severity' => '4'))
      ).to have_been_made.once
    end
  end
end
